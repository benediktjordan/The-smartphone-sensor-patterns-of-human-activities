#region import
import pandas as pd
import pickle
import time
import numpy as np

#endregion

#region create merge object/class
class Merge_and_Impute:
    def merge(df_base, df_tomerge, timedelta, columns_to_delete):
        df_final = pd.DataFrame()

        # harmonize column names
        ## if there is a column named "2" in df_tomerge, rename it to "device_id"
        if "2" in df_base.columns:
            df_base = df_base.rename(columns={"2": "device_id"})
        if "2" in df_tomerge.columns:
            df_tomerge = df_tomerge.rename(columns={"2": "device_id"})
        if "device_id" not in df_base.columns:
            for col in df_base.columns:
                if "device_id" in col:
                    df_base = df_base.rename(columns={col: "device_id"})
        if "device_id" not in df_tomerge.columns:
            for col in df_tomerge.columns:
                if "device_id" in col:
                    df_tomerge = df_tomerge.rename(columns={col: "device_id"})

        ## if there is a column named "sensor_timestamp", rename it to "timestamp"
        if "sensor_timestamp" in df_base.columns:
            df_base = df_base.rename(columns={"sensor_timestamp": "timestamp"})
        if "sensor_timestamp" in df_tomerge.columns:
            df_tomerge = df_tomerge.rename(columns={"sensor_timestamp": "timestamp"})

        user_count = 1
        total_users = len(df_base['device_id'].unique())
        # iterate through participants and ESM_timestamps
        for user in df_base['device_id'].unique():
            time_start = time.time()

            df_base_user = df_base[df_base['device_id'] == user]
            df_tomerge_user = df_tomerge[df_tomerge['device_id'] == user]

            # make sure that timestamp coluns are in datetime format
            df_base_user['timestamp'] = pd.to_datetime(df_base_user['timestamp'])
            df_tomerge_user['timestamp'] = pd.to_datetime(df_tomerge_user['timestamp'])

            # sort dataframes by timestamp
            df_base_user = df_base_user.sort_values(by='timestamp')
            df_tomerge_user = df_tomerge_user.sort_values(by='timestamp')

            # duplicate timestamp column for test purposes
            df_tomerge_user['timestamp_merged'] = df_tomerge_user['timestamp']

            # delete columns from df_tomerger_user that dont have to be merged
            df_tomerge_user = df_tomerge_user.drop(columns= columns_to_delete)
            df_tomerge_user = df_tomerge_user.drop(columns=['device_id'])

            # delete columns "Unnamed: 0", "0", "1" and "2" from df_sensor_user_event: all the information of these
            # columns is already contained in the JSON data
            #df_sensor_user_event = df_sensor_user_event.drop(columns=['Unnamed: 0', '0', '1', '2'])

            # merge dataframes
            df_merged = pd.merge_asof(df_base_user, df_tomerge_user, on='timestamp',
                                      tolerance=pd.Timedelta(timedelta), direction='nearest')
            # Explanation: this function looks for every entry in the left timeseries if there is a
            # entry in the right timeseries which is max. "timedelta" time apart
            # TODO: include functionality so that also sensors with lesser frequency can be merged (i.e.
            #  locations, open_wheather etc.)

            # concatenate df_merged to df_final
            df_final = pd.concat([df_final, df_merged], axis=0)

            print("Time for User " + str(user_count) + "/" + str(total_users) + " was " + str((time.time()-time_start)/60) + " minutes")
            user_count += 1
        return df_final

    def impute_deleteNaN(df_final):
        # delete rows with NaN values
        df_final = df_final.dropna(axis=0, how='any')
        return df_final

    #TODO include here imputation methods:
    # - fill by last / next value
    # - fill by mean




# region create merged timeseries
#TODO integrate these functions into "Merge_and_Impute" class (more exact: check if Merge_and_Impute class works for timeseries merging)
## import data
sensors_included = ["linear_accelerometer", "rotation"]
timedelta = "100ms"
col_to_delete = ['Unnamed: 0', '0', '1', "ESM_timestamp"]
# check which sensor file contains the most rows; this will be the base file
# (the other files will be merged into this one)
max_rows = 0
sensors_to_merge = []
for sensor in sensors_included:
    df = pd.read_pickle(
        "/Users/benediktjordan/Documents/MTS/Iteration01/Data/data_preparation/xmin_around_events/" + sensor + "_esm_timeperiod_5 min.csv_JSONconverted.pkl")
    if len(df) > max_rows and max_rows == 0:
        max_rows = len(df)
        base_sensor = sensor
        print("Base sensor is " + base_sensor)
        print("Number of rows: " + str(max_rows))
    elif len(df) > max_rows and max_rows != 0:
        sensors_to_merge.append(base_sensor)
        base_sensor = sensor
        print("The new base sensor is " + sensor)
        print("Number of rows: " + str(len(df)))
    else:
        #add sensor to list of sensors to merge
        sensors_to_merge.append(sensor)
del df

#sensors = ["accelerometer", "gravity",
#           "gyroscope", "magnetometer", "rotation"]

## iterate through sensors
#TODO: also merge sensors with lesser frequency (i.e. locations, open_weather etc.)

df_base = pd.read_pickle("/Users/benediktjordan/Documents/MTS/Iteration01/Data/data_preparation/xmin_around_events/" + str(
    base_sensor) + "_esm_timeperiod_5 min.csv_JSONconverted.pkl")
sensors_included_string = ""
for sensor in sensors_to_merge:
    time_begin = time.time()
    sensors_included_string += "-" + sensor
    print("Current sensor is: ", sensor)
    df_sensor = pd.read_pickle(
        "/Users/benediktjordan/Documents/MTS/Iteration01/Data/data_preparation/xmin_around_events/" + sensor + "_esm_timeperiod_5 min.csv_JSONconverted.pkl")
    #df_base = merge_unaligned_timeseries(df_base, df_tomerge=df_sensor, merge_sensor=sensor)
    df_base = Merge_and_Impute.merge(df_base, df_tomerge=df_sensor, timedelta=timedelta, columns_to_delete= col_to_delete)
    df_base.to_csv("/Users/benediktjordan/Documents/MTS/Iteration01/Data/data_preparation/timeseries_merged/" + str(base_sensor) + "_with" + str(sensors_included_string) + "_esm_timeperiod_5 min_TimeseriesMerged.csv", index=False)
    time_end = time.time()
    print("Time for sensor ", sensor, " is: ", time_end - time_begin)

# endregion

##region merging function (OUTDATED; I AM USING NOW THE MERGE_AND_IMPUTE CLASS)
def merge_unaligned_timeseries(df_base, df_tomerge, merge_sensor):
    df_final = pd.DataFrame()
    user_count = 0

    #convert timestamp column to datetime format
    df_base['timestamp'] = pd.to_datetime(df_base['timestamp'])
    df_tomerge['timestamp'] = pd.to_datetime(df_tomerge['timestamp'])
    df_base["ESM_timestamp"] = pd.to_datetime(df_base["ESM_timestamp"])
    df_tomerge["ESM_timestamp"] = pd.to_datetime(df_tomerge["ESM_timestamp"])

    # iterate through devices and ESM_timestamps
    number_of_events = len(df_base['ESM_timestamp'].unique())
    counter = 1
    for event in df_base['ESM_timestamp'].unique():
        print("Event " + str(counter) + "/" + str(number_of_events))
        counter += 1

        # get data for specific user and ESM event
        df_base_event = df_base[df_base['ESM_timestamp'] == event]
        df_tomerge_event = df_tomerge[df_tomerge['ESM_timestamp'] == event]

        # sort dataframes by timestamp
        df_base_event = df_base_event.sort_values(by='timestamp')
        df_tomerge_event = df_tomerge_event.sort_values(by='timestamp')

        # duplicate timestamp column for test purposes
        df_tomerge_event['timestamp_' + str(merge_sensor)] = df_tomerge_event['timestamp'].copy()

        # delete all ESM-related columns in df_sensor_user_event (otherwise they would be duplicated)
        #df_sensor_user_event = df_sensor_user_event.drop(
        #    columns=['ESM_timestamp', "ESM_location", "ESM_location_time",
        #             "ESM_bodyposition", "ESM_bodyposition_time",
        #             "ESM_activity", "ESM_activity_time",
        #             "ESM_smartphonelocation", "ESM_smartphonelocation_time",
        #             "ESM_aligned", "ESM_aligned_time"])
        # delete columns "Unnamed: 0", "0", "1" and "2" from df_sensor_user_event: all the information of these
        # columns is already contained in the JSON data
        df_tomerge_event = df_tomerge_event.drop(columns=['Unnamed: 0', '0', '1', '2', "ESM_timestamp"])

        # merge dataframes
        df_merged = pd.merge_asof(df_base_event, df_tomerge_event, on='timestamp',
                                  tolerance=pd.Timedelta("100ms"))
        # TODO: include functionality so that also sensors with lesser frequency can be merged (i.e.
        #  locations, open_wheather etc.)

        # add merged data to 00_general dataframe
        df_final = pd.concat([df_final, df_merged], axis=0)
    return df_final
#endregion

#region temporary
df_base = pd.read_csv(
    "/Users/benediktjordan/Documents/MTS/Iteration01/Data/magnetometer_esm_timeperiod_5 min_TimeseriesMerged.csv",
    parse_dates=['timestamp', "1", "timestamp_accelerometer"], infer_datetime_format=True)

test = df_base["1"] - df_base["timestamp"]
test2 = df_base["1"] - df_base["timestamp_accelerometer"]
test.describe()
test2.describe()

df_base = df_base.drop(columns=['ESM_timestamp_y', "ESM_location_y", "ESM_location_time_y",
                                "ESM_bodyposition_y", "ESM_bodyposition_time_y",
                                "ESM_activity_y", "ESM_activity_time_y",
                                "ESM_smartphonelocation_y", "ESM_smartphonelocation_time_y",
                                "ESM_aligned_y", "ESM_aligned_time_y",
                                "Unnamed: 0_y", "0_y", "1_y", "2_y", "3_y"])
df_base = df_base.rename(columns={"Unnamed: 0_x": "Unnamed: 0", "0_x": "0", "1_x": "1", "2_x": "2", "3_x": "3",
                                  "ESM_timestamp_x": "ESM_timestamp", "ESM_location_x": "ESM_location",
                                  "ESM_location_time_x": "ESM_location_time", "ESM_bodyposition_x": "ESM_bodyposition",
                                  "ESM_bodyposition_time_x": "ESM_bodyposition_time", "ESM_activity_x": "ESM_activity",
                                  "ESM_activity_time_x": "ESM_activity_time",
                                  "ESM_smartphonelocation_x": "ESM_smartphonelocation",
                                  "ESM_smartphonelocation_time_x": "ESM_smartphonelocation_time",
                                  "ESM_aligned_x": "ESM_aligned",
                                  "ESM_aligned_time_x": "ESM_aligned_time"})

# endregion temporary

